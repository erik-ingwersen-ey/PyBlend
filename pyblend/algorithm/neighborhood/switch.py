import random
from typing import List, Optional, Tuple

from pyblend.algorithm.constructive import Constructive
from pyblend.algorithm.neighborhood.move import Move
from pyblend.model.classes import Engine
from pyblend.model.problem import Problem
from pyblend.model.solution import Solution


class Switch(Move):
    """
    Class representing a Switch Move.

    A neighbor in the `Switch` move is generated by switching
    the order of two jobs from a machine.

    """

    def __init__(
        self: 'Switch', 
        problem: Problem, 
        constructive: Constructive
    ):
        """
        Instantiate a new `Switch` Move.

        Parameters
        ----------
        problem : Problem
            The problem reference.
        constructive : Constructive
            The move constructive procedure.
        """
        super().__init__(problem, constructive, 'Switch')

        self._engine: Engine = random.choice(problem.engines)

        self._job_1: Optional[int] = None
        self._job_2: Optional[int] = None        

    def accept(self: 'Switch') -> None:
        """
        Method called whenever the modification made by a move is accepted.

        It ensures that the solution as well as other structures are updated accordingly.
        """
        super().accept()

    def reject(self: 'Switch') -> None:
        """
        Method that is called whenever a move modification is rejected.

        This is done to ensure that the solution as well as other structures
        are updated accordingly.
        """
        super().reject()

        route: List[Tuple[int, str]] = self._current_solution.routes[self._engine.id - 1]

        route[self._job_1], route[self._job_2] = route[self._job_2], route[self._job_1]

        self._constructive.run(True)

    def do_move(self: 'Switch', solution: Solution) -> float:
        """
        Calculate the move's impact on the delta cost of the solution.

        Parameters
        ----------
        solution : Solution
            The solution to modify.

        Returns
        -------
        float
            The impact delta cost of this move in the solution.
        """
        route: List[Tuple[int, str]] = solution.routes[self._engine.id - 1]

        self._job_1, self._job_2 = [
            tuple(i)[0] for i in random.sample(list(enumerate(route)), 2)
        ]

        route[self._job_1], route[self._job_2] = route[self._job_2], route[self._job_1]

        return super().do_move(solution)

    def gen_move(self: 'Switch', solution: Solution) -> None:
        """
        Method generates a random candidate for the movement.

        The function `has_move` has to subsequently validate the movement.

        Parameters
        ----------
        solution : Solution
            The solution to modify.
        """
        # resets the current neighborhood so that new ones can be explored
        self.reset()

        for _ in range(int(1e3)):
            self._engine = random.choice(self._problem.engines)
            if self.has_move(solution):
                break

    def has_move(self: 'Switch', solution: Solution) -> bool:
        """
        Boolean to indicate whether a neighborhood can be applied to the current solution.

        Parameters
        ----------
        solution : Solution
            The solution to evaluate.

        Returns
        -------
        bool
            Returns `True` if this neighborhood can be applied to the current
            solution, and `False` otherwise.
        """
        return len(solution.routes[self._engine.id - 1]) > 1

    def reset(self: 'Switch') -> None:
        """
        Method called whenever the neighborhood needs to be reset.

        This is mainly used to avoid the need of creating new objects.
        """
        self._engine = random.choice(self._problem.engines)
        
        self._job_1 = None
        self._job_2 = None

    @property
    def engine(self: 'Switch') -> Engine:
        """Engine: The engine reference."""
        return self._engine

    @engine.setter
    def engine(self: 'Switch', value: Engine) -> None:
        self._engine = value

    @property
    def job_1(self: 'Switch') -> Optional[int]:
        """The index of the first job."""
        return self._job_1

    @job_1.setter
    def job_1(self: 'Switch', value: Optional[int]) -> None:
        self._job_1 = value

    @property
    def job_2(self: 'Switch') -> Optional[int]:
        """The index of the second job."""
        return self._job_2

    @job_2.setter
    def job_2(self: 'Switch', value: Optional[int]) -> None:
        self._job_2 = value
