from __future__ import annotations

import random
from typing import List, Optional, Tuple

from pyblend.algorithm.constructive import Constructive
from pyblend.algorithm.neighborhood.move import Move
from pyblend.model.problem import Problem
from pyblend.model.solution import Solution


class SmartShift(Move):
    """
    Class representing a Smart Shift Move.

    A neighbor in the Smart Shift Move is generated by re-scheduling
    the job from the machine with the largest total execution time
    to another position in the machine.
    """

    def __init__(
        self: 'SmartShift', 
        problem: Problem, 
        constructive: Constructive
    ):
        """
        Instantiates a new `SmartShift` Move.

        Parameters
        ----------
        problem : Problem
            The problem reference.
        constructive : Constructive
            The move constructive procedure.
        """
        super().__init__(problem, constructive, 'SmartShift')

        self._make_span: List[Tuple[float, int]] = []
        self._engine_id: Optional[int] = None
        self._route: List[Tuple[int, str]] = []
        self._job: Tuple[int, str] | tuple = ()
        self._pos: Optional[int] = None

    def accept(self: 'SmartShift') -> None:
        """
        Method called whenever the modification made by a move is accepted.

        It ensures that the solution as well as other structures are updated accordingly.
        """

        super().accept()

    def reject(self: 'SmartShift') -> None:
        """
        Method that is called whenever a move modification is rejected.

        This is done to ensure that the solution as well as other structures
        are updated accordingly.
        """

        super().reject()

        self._route.remove(self._job)
        self._route.insert(self._pos, self._job)

        self._constructive.run(True)

    def do_move(self: 'SmartShift', solution: Solution) -> float:
        """
        Calculate the move's impact on the delta cost of the solution.

        Parameters
        ----------
        solution : Solution
            The solution to modify.

        Returns
        -------
        float
            The impact delta cost of this move in the solution.
        """

        self._job = random.choice(self._route)
        self._pos = self._route.index(self._job)

        self._route.remove(self._job)
        self._route.insert(random.randrange(len(self._route)), self._job)

        return super().do_move(solution)

    def gen_move(self: 'SmartShift', solution: Solution) -> None:
        """
        Method generates a random candidate for the movement.

        The function `has_move` has to subsequently validate the movement.

        Parameters
        ----------
        solution : Solution
            The solution to modify.
        """

        self._current_solution = solution

        # resets the current neighborhood so that new ones can be explored
        self.reset()

        for _ in range(int(1e3)):
            self._engine_id = random.choice(self._make_span)[1]
            self._route = self._current_solution.routes[self._engine_id - 1]
            if self.has_move(solution):
                break

    def has_move(self: 'SmartShift', solution: Solution) -> bool:
        """
        Boolean to indicate whether a neighborhood can be applied to the current solution.

        Parameters
        ----------
        solution : Solution
            The solution to evaluate.

        Returns
        -------
        bool
            Returns `True` if this neighborhood can be applied to the current
            solution, and `False` otherwise.
        """

        return len(self._route) > 1

    def reset(self: 'SmartShift') -> None:
        """
        Method called whenever the neighborhood needs to be reset.

        This is mainly used to avoid the need of creating new objects.
        """

        engine_duration: List[Tuple[float, int]] = [
            (item['duration'], item['engine']) 
            for item in self._current_solution.reclaims
        ]

        self._make_span = list(filter(
            lambda x: x[0] == max(engine_duration)[0], 
            engine_duration
        ))

        self._engine_id = random.choice(self._make_span)[1]
        self._route = self._current_solution.routes[self._engine_id - 1]
        self._job = random.choice(self._route)
        self._pos = self._route.index(self._job)

    @property
    def make_span(self: 'SmartShift') -> List[Tuple[float, int]]:
        """
        List of tuples with the 'makespan' and the id of each engine.
        """
        return self._make_span

    @make_span.setter
    def make_span(self: 'SmartShift', value: List[Tuple[float, int]]) -> None:
        self.make_span = value

    @property
    def engine_id(self: 'SmartShift') -> Optional[int]:
        """The engine id."""
        return self._engine_id

    @engine_id.setter
    def engine_id(self: 'SmartShift', value: Optional[int]) -> None:
        self._engine_id = value

    @property
    def route(self: 'SmartShift') -> List[Tuple[int, str]]:
        """The route of the engine."""
        return self._route

    @route.setter
    def route(self: 'SmartShift', value: List[Tuple[int, str]]) -> None:
        self._route = value

    @property
    def job(self: 'SmartShift') -> Tuple[int, str]:
        """The selected job from the engine route."""
        return self._job

    @job.setter
    def job(self: 'SmartShift', value: Tuple[int, str]) -> None:
        self._job = value

    @property
    def pos(self: 'SmartShift') -> Optional[int]:
        """The index of the job."""
        return self._pos

    @pos.setter
    def pos(self: 'SmartShift', value: Optional[int]) -> None:
        self._pos = value
