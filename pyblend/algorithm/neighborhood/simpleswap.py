from __future__ import annotations

import random
from typing import List, Optional, Tuple

from pyblend.algorithm.constructive import Constructive
from pyblend.algorithm.neighborhood.move import Move
from pyblend.model.classes import Engine
from pyblend.model.problem import Problem
from pyblend.model.solution import Solution


class SimpleSwap(Move):
    """
    Class representing a Simple Swap Move.

    A neighbor in the Simple Swap Neighborhood is generated by swapping
    two jobs between two machines.

    Note that the swapped jobs are placed in the same position on the other
    machine. In other words, the original positions are taken into account.
    This Move first removes the two jobs and then reinserts them in the equivalent
    positions.
    """ 	
    
    def __init__(
        self: 'SimpleSwap', 
        problem: Problem, 
        constructive: Constructive
    ):
        """Instantiates a new `SimpleSwap` Move.

        Parameters
        ----------
        problem : Problem
            The problem reference.
        constructive : Constructive
            The move constructive procedure.
        """

        super().__init__(problem, constructive, 'SimpleSwap')

        self._engine_1: Engine = random.choice(problem.engines)
        self._engine_2: Engine = random.choice(problem.engines)

        # try to get the engine from the neighboring yard
        index: int = problem.engines.index(self._engine_1)
        try:
            self._engine_2 = problem.engines[index + 1]

        except IndexError:
            self._engine_2 = problem.engines[index - 1]

        self._route_1: List[Tuple[int, str]] = []
        self._route_2: List[Tuple[int, str]] = []

        self._job_1: Tuple[int, str] | tuple = ()
        self._job_2: Tuple[int, str] | tuple = ()

        self._pos_1: Optional[int] = None
        self._pos_2: Optional[int] = None

    def accept(self: 'SimpleSwap') -> None:
        """
        Method called whenever the modification made by a move is accepted.

        It ensures that the solution as well as other structures are updated accordingly.
        """

        super().accept()

    def reject(self: 'SimpleSwap') -> None:
        """
        Method that is called whenever a move modification is rejected.

        This is done to ensure that the solution as well as other structures
        are updated accordingly.
        """
        super().reject()

        self._route_1.remove(self._job_2)
        self._route_2.remove(self._job_1)

        self._route_1.insert(self._pos_1, self._job_1)
        self._route_2.insert(self._pos_2, self._job_2)

        self._constructive.run(True)

    def do_move(self: 'SimpleSwap', solution: Solution) -> float:
        """
        Calculate the move's impact on the delta cost of the solution.
    
        Parameters
        ----------
        solution : Solution
            The solution to modify.

        Returns
        -------
        float
            The impact delta cost of this move in the solution.
        """

        self._pos_1 = self._route_1.index(self._job_1)
        self._pos_2 = self._route_2.index(self._job_2)

        self._route_1.remove(self._job_1)
        self._route_2.remove(self._job_2)

        self._route_1.insert(self._pos_1, self._job_2)
        self._route_2.insert(self._pos_2, self._job_1)

        return super().do_move(solution)

    def gen_move(self: 'SimpleSwap', solution: Solution) -> None:
        """
        Method generates a random candidate for the movement.

        The function `has_move` has to subsequently validate the movement.
        
        Parameters
        ----------
        solution : Solution
            The solution to modify.
        """

        self._current_solution = solution

        # resets the current neighborhood so that new ones can be explored
        self.reset()

        for _ in range(int(1e3)):
            self._job_1 = random.choice(self._route_1)
            self._pos_1 = self._route_1.index(self._job_1)

            try:
                self._pos_2 = self._pos_1
                self._job_2 = self._route_2[self._pos_2]

            except IndexError:
                self._job_2 = random.choice(self._route_2)
                self._pos_2 = self._route_2.index(self._job_2)

            if self.has_move(solution):
                break

    def has_move(self: 'SimpleSwap', solution: Solution) -> bool:
        """
        Boolean to indicate whether a neighborhood can be applied to the current solution.

        Parameters
        ----------
        solution : Solution
            The solution to evaluate.
        
        Returns
        -------
        bool
            Returns `True` if this neighborhood can be applied to the current
            solution, and `False` otherwise.
        """

        return self._job_1[1] == self._job_2[1] and self._pos_1 == self._pos_2

    def reset(self: 'SimpleSwap') -> None:
        """
        Method called whenever the neighborhood needs to be reset.

        This is mainly used to avoid the need of creating new objects.
        """

        self._engine_1 = random.choice(self._problem.engines)

        # try to get the engine from the neighboring yard
        index: int = self._problem.engines.index(self._engine_1)
        try:
            self._engine_2 = self._problem.engines[index + 1]

        except IndexError:
            self._engine_2 = self._problem.engines[index - 1]

        self._route_1 = self._current_solution.routes[self._engine_1.id - 1]
        self._route_2 = self._current_solution.routes[self._engine_2.id - 1]

        self._job_1 = random.choice(self._route_1)
        self._pos_1 = self._route_1.index(self._job_1)

        self._job_2 = random.choice(self._route_2)
        self._pos_2 = self._route_2.index(self._job_2)

    @property
    def engine_1(self: 'SimpleSwap') -> Engine:
        """Engine: The first engine reference."""
        return self._engine_1

    @engine_1.setter
    def engine_1(self: 'SimpleSwap', value: Engine) -> None:
        self._engine_1 = value

    @property
    def engine_2(self: 'SimpleSwap') -> Engine:
        """Engine: The second reference."""
        return self._engine_2

    @engine_2.setter
    def engine_2(self: 'SimpleSwap', value: Engine) -> None:
        self._engine_2 = value

    @property
    def route_1(self: 'SimpleSwap') -> List[Tuple[int, str]]:
        """The route of the first engine."""
        return self._route_1

    @route_1.setter
    def route_1(self: 'SimpleSwap', value: List[Tuple[int, str]]) -> None:
        self._route_1 = value

    @property
    def route_2(self: 'SimpleSwap') -> List[Tuple[int, str]]:
        """The route of the second engine."""
        return self._route_2

    @route_2.setter
    def route_2(self: 'SimpleSwap', value: List[Tuple[int, str]]) -> None:
        self._route_2 = value

    @property
    def job_1(self: 'SimpleSwap') -> Tuple[int, str]:
        """The selected job from the first engine route."""
        return self._job_1

    @job_1.setter
    def job_1(self: 'SimpleSwap', value: Tuple[int, str]) -> None:
        self._job_1 = value

    @property
    def job_2(self: 'SimpleSwap') -> Tuple[int, str]:
        """The selected job from the second engine route."""
        return self._job_2

    @job_2.setter
    def job_2(self: 'SimpleSwap', value: Tuple[int, str]) -> None:
        self._job_2 = value

    @property
    def pos_1(self: 'SimpleSwap') -> Optional[int]:
        """The index of the first job."""
        return self._pos_1

    @pos_1.setter
    def pos_1(self: 'SimpleSwap', value: Optional[int]) -> None:
        self._pos_1 = value

    @property
    def pos_2(self: 'SimpleSwap') -> Optional[int]:
        """The index of the second job."""
        return self._pos_2

    @pos_2.setter
    def pos_2(self: 'SimpleSwap', value: Optional[int]) -> None:
        self._pos_2 = value
