import random
from typing import List, Optional, Tuple

from pyblend.algorithm.constructive import Constructive
from pyblend.algorithm.neighborhood.move import Move
from pyblend.model.problem import Problem
from pyblend.model.solution import Solution


class SmartSwitch(Move):
    """
    Class representing a Smart Switch Move.

    A neighbor in the `SmartSwitch` move is generated by switching
    the order of two jobs from the machine with the largest total execution time.
    """

    def __init__(
        self: 'SmartSwitch', 
        problem: Problem, 
        constructive: Constructive
    ):
        """
        Instantiate a new `SmartSwitch` Move.

        Parameters
        ----------
        problem : Problem
            The problem reference.
        constructive : Constructive
            The move constructive procedure.
        """
        super().__init__(problem, constructive, 'SmartSwitch')

        self._make_span: List[Tuple[float, int]] = []
        self._engine_id: Optional[int] = None

        self._job_1: Optional[int] = None
        self._job_2: Optional[int] = None        

    def accept(self: 'SmartSwitch') -> None:
        """
        Method called whenever the modification made by a move is accepted.

        It ensures that the solution as well as other structures are updated accordingly.
        """
        super().accept()

    def reject(self: 'SmartSwitch') -> None:
        """
        Method that is called whenever a move modification is rejected.

        This is done to ensure that the solution as well as other structures
        are updated accordingly.
        """
        super().reject()

        route: List[Tuple[int, str]] = self._current_solution.routes[self._engine_id - 1]

        route[self._job_1], route[self._job_2] = route[self._job_2], route[self._job_1]

        self._constructive.run(True)

    def do_move(self: 'SmartSwitch', solution: Solution) -> float:
        """
        Calculate the move's impact on the delta cost of the solution.

        Parameters
        ----------
        solution : Solution
            The solution to modify.

        Returns
        -------
        float
            The impact delta cost of this move in the solution.
        """
        route: List[Tuple[int, str]] = solution.routes[self._engine_id - 1]

        self._job_1, self._job_2 = [
            tuple(i)[0] for i in random.sample(list(enumerate(route)), 2)
        ]

        route[self._job_1], route[self._job_2] = \
            route[self._job_2], route[self._job_1]

        return super().do_move(solution)

    def gen_move(self: 'SmartSwitch', solution: Solution) -> None:
        """
        Method generates a random candidate for the movement.

        The function `has_move` has to subsequently validate the movement.

        Parameters
        ----------
        solution : Solution
            The solution to modify.
        """
        self._current_solution = solution

        # resets the current neighborhood so that new ones can be explored
        self.reset()

        for _ in range(int(1e3)):
            self._engine_id = random.choice(self._make_span)[1]
            if self.has_move(solution):
                break

    def has_move(self: 'SmartSwitch', solution: Solution) -> bool:
        """
        Boolean to indicate whether a neighborhood can be applied to the current solution.

        Parameters
        ----------
        solution : Solution
            The solution to evaluate.

        Returns
        -------
        bool
            Returns `True` if this neighborhood can be applied to the current
            solution, and `False` otherwise.
        """
        return len(solution.routes[self._engine_id - 1]) > 1

    def reset(self: 'SmartSwitch') -> None:
        """
        Method called whenever the neighborhood needs to be reset.

        This is mainly used to avoid the need of creating new objects.
        """
        engine_duration: List[Tuple[float, int]] = [
            (item['duration'], item['engine']) 
            for item in self._current_solution.reclaims
        ]

        self._make_span = list(filter(
            lambda x: x[0] == max(engine_duration)[0], 
            engine_duration
        ))

        self._engine_id = random.choice(self._make_span)[1]
        
        self._job_1 = None
        self._job_2 = None

    @property
    def make_span(self: 'SmartSwitch') -> List[Tuple[float, int]]:
        """
        List of tuples with the 'makespan' and the id of each engine.
        """
        return self._make_span

    @make_span.setter
    def make_span(self: 'SmartSwitch', value: List[Tuple[float, int]]) -> None:
        self.make_span = value

    @property
    def engine_id(self: 'SmartSwitch') -> Optional[int]:
        """The engine id."""
        return self._engine_id

    @engine_id.setter
    def engine_id(self: 'SmartSwitch', value: Optional[int]) -> None:
        self._engine_id = value

    @property
    def job_1(self: 'SmartSwitch') -> Optional[int]:
        """The index of the first job."""
        return self._job_1

    @job_1.setter
    def job_1(self: 'SmartSwitch', value: Optional[int]) -> None:
        self._job_1 = value

    @property
    def job_2(self: 'SmartSwitch') -> Optional[int]:
        """The index of the second job."""
        return self._job_2

    @job_2.setter
    def job_2(self: 'SmartSwitch', value: Optional[int]) -> None:
        self._job_2 = value
